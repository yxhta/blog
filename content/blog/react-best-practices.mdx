---
title: 'React Best Practices for 2024'
description: 'Modern React development patterns and best practices every developer should know'
author: 'Jane Smith'
date: 2024-01-15
tags: ['react', 'javascript', 'frontend', 'best-practices']
category: 'Frontend Development'
---

# React Best Practices for 2024

React continues to evolve, and with it, the best practices for building maintainable and performant applications. Here are the key patterns you should adopt in 2024.

## 1. Use Functional Components with Hooks

Modern React development favors functional components over class components:

```tsx
// âœ… Good: Functional component with hooks
import { useState, useEffect } from 'react';

interface User {
  id: number;
  name: string;
}

function UserProfile({ userId }: { userId: number }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>ID: {user.id}</p>
    </div>
  );
}
```

## 2. Custom Hooks for Reusable Logic

Extract common logic into custom hooks:

```typescript
// Custom hook for API calls
function useApi<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch');
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [url]);

  return { data, loading, error };
}
```

## 3. Proper Error Boundaries

Implement error boundaries for better error handling:

```tsx
import { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

## 4. Optimize with React.memo and useMemo

Prevent unnecessary re-renders:

```tsx
import { memo, useMemo } from 'react';

interface ExpensiveComponentProps {
  data: number[];
  multiplier: number;
}

const ExpensiveComponent = memo(({ data, multiplier }: ExpensiveComponentProps) => {
  const processedData = useMemo(() => {
    return data.map(item => item * multiplier);
  }, [data, multiplier]);

  return (
    <ul>
      {processedData.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
});
```

## Key Takeaways

1. **Use TypeScript** for better type safety
2. **Keep components small** and focused on single responsibilities
3. **Use custom hooks** to share logic between components
4. **Implement proper error handling** with error boundaries
5. **Optimize performance** with memoization when needed

These practices will help you build more maintainable and efficient React applications in 2024.